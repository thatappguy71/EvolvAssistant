// =================================================================
// COMPLETE EVOLV ANDROID APP - ALL CODE FOR ANDROID STUDIO BUILD
// =================================================================

// ===============================
// 1. BUILD.GRADLE FILES
// ===============================

// PROJECT LEVEL build.gradle
buildscript {
    ext {
        compose_version = '1.5.8'
        hilt_version = '2.48.1'
    }
    dependencies {
        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.48.1'
    }
}

plugins {
    id 'com.android.application' version '8.2.1' apply false
    id 'com.android.library' version '8.2.1' apply false
    id 'org.jetbrains.kotlin.android' version '1.9.22' apply false
}

// APP LEVEL build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
    id 'kotlin-parcelize'
    id 'kotlinx-serialization'
}

android {
    namespace 'com.yourname.evolv'
    compileSdk 34

    defaultConfig {
        applicationId "com.yourname.evolv"
        minSdk 26
        targetSdk 34
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary true
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            minifyEnabled false
            debuggable true
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
        coreLibraryDesugaringEnabled true
    }
    
    kotlinOptions {
        jvmTarget = '1.8'
    }
    
    buildFeatures {
        compose true
        mlModelBinding true
    }
    
    composeOptions {
        kotlinCompilerExtensionVersion '1.5.8'
    }
    
    packagingOptions {
        resources {
            excludes += '/META-INF/{AL2.0,LGPL2.1}'
        }
    }
    
    aaptOptions {
        noCompress "tflite"
    }
}

dependencies {
    // Core Android
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.7.0'
    implementation 'androidx.activity:activity-compose:1.8.2'
    implementation 'androidx.work:work-runtime-ktx:2.9.0'
    
    // Compose BOM
    implementation platform('androidx.compose:compose-bom:2024.02.00')
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.ui:ui-graphics'
    implementation 'androidx.compose.ui:ui-tooling-preview'
    implementation 'androidx.compose.material3:material3'
    implementation 'androidx.compose.material:material-icons-extended'
    implementation 'androidx.compose.animation:animation'
    
    // Navigation
    implementation 'androidx.navigation:navigation-compose:2.7.6'
    
    // ViewModel
    implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0'
    implementation 'androidx.lifecycle:lifecycle-runtime-compose:2.7.0'
    
    // Room database
    implementation 'androidx.room:room-runtime:2.6.1'
    implementation 'androidx.room:room-ktx:2.6.1'
    kapt 'androidx.room:room-compiler:2.6.1'
    
    // Hilt for dependency injection
    implementation 'com.google.dagger:hilt-android:2.48.1'
    kapt 'com.google.dagger:hilt-compiler:2.48.1'
    implementation 'androidx.hilt:hilt-navigation-compose:1.1.0'
    implementation 'androidx.hilt:hilt-work:1.1.0'
    kapt 'androidx.hilt:hilt-compiler:1.1.0'
    
    // Date and time
    implementation 'org.jetbrains.kotlinx:kotlinx-datetime:0.5.0'
    coreLibraryDesugaring 'com.android.tools:desugar_jdk_libs:2.0.4'
    
    // Charts and visualization
    implementation 'com.github.PhilJay:MPAndroidChart:v3.1.0'
    implementation 'androidx.compose.foundation:foundation:1.5.8'
    
    // Health Connect
    implementation 'androidx.health.connect:connect-client:1.1.0-alpha06'
    
    // TensorFlow Lite for ML
    implementation 'org.tensorflow:tensorflow-lite:2.14.0'
    implementation 'org.tensorflow:tensorflow-lite-support:0.4.4'
    implementation 'org.tensorflow:tensorflow-lite-metadata:0.4.4'
    
    // Serialization for export/import
    implementation 'org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.2'
    
    // File operations
    implementation 'androidx.documentfile:documentfile:1.0.1'
    
    // Billing
    implementation 'com.android.billingclient:billing-ktx:6.1.0'
    
    // Permissions
    implementation 'com.google.accompanist:accompanist-permissions:0.32.0'
    
    // Coroutines
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3'
    
    // Testing
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation platform('androidx.compose:compose-bom:2024.02.00')
    androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
    debugImplementation 'androidx.compose.ui:ui-tooling'
    debugImplementation 'androidx.compose.ui:ui-test-manifest'
}

// ===============================
// 2. ANDROID MANIFEST
// ===============================

// AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Standard permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.VIBRATE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.USE_EXACT_ALARM" />
    <uses-permission android:name="com.android.vending.BILLING" />
    
    <!-- Health Connect permissions -->
    <uses-permission android:name="android.permission.health.READ_HEART_RATE" />
    <uses-permission android:name="android.permission.health.READ_SLEEP" />
    <uses-permission android:name="android.permission.health.READ_STEPS" />
    <uses-permission android:name="android.permission.health.READ_DISTANCE" />
    <uses-permission android:name="android.permission.health.READ_ACTIVE_CALORIES_BURNED" />
    <uses-permission android:name="android.permission.health.READ_EXERCISE" />
    <uses-permission android:name="android.permission.health.WRITE_EXERCISE" />

    <application
        android:name=".EvolvApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Evolv"
        tools:targetApi="31">
        
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:theme="@style/Theme.Evolv">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <!-- Broadcast receivers for notifications -->
        <receiver
            android:name=".notifications.HabitReminderReceiver"
            android:enabled="true"
            android:exported="false" />
            
        <receiver
            android:name=".notifications.HabitActionReceiver"
            android:enabled="true"
            android:exported="false" />
        
    </application>

</manifest>

// ===============================
// 3. DATA MODELS
// ===============================

// data/model/UserSubscription.kt
package com.yourname.evolv.data.model

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.TypeConverter
import kotlinx.serialization.Serializable
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

@Entity(tableName = "user_subscription")
data class UserSubscriptionEntity(
    @PrimaryKey
    val userId: String = "default_user",
    val subscriptionTier: UserTier = UserTier.FREE,
    val subscriptionId: String? = null,
    val purchaseToken: String? = null,
    val startDate: LocalDateTime? = null,
    val endDate: LocalDateTime? = null,
    val isActive: Boolean = false,
    val autoRenew: Boolean = false,
    val trialEndDate: LocalDateTime? = null,
    val isTrialActive: Boolean = false,
    val lastUpdated: LocalDateTime = LocalDateTime.now()
)

enum class UserTier {
    FREE, PREMIUM, ENTERPRISE
}

@Entity(tableName = "habits")
data class HabitEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val name: String,
    val category: String,
    val description: String = "",
    val timeRequired: String,
    val difficulty: String = "Easy",
    val isActive: Boolean = true,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val updatedAt: LocalDateTime = LocalDateTime.now()
)

@Entity(tableName = "habit_completions")
data class HabitCompletionEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val habitId: Long,
    val completedAt: LocalDateTime,
    val rating: Int? = null,
    val notes: String = ""
)

@Entity(tableName = "daily_metrics")
data class DailyMetricEntity(
    @PrimaryKey
    val date: String,
    val energy: Int,
    val focus: Int,
    val mood: Int,
    val productivity: Int,
    val sleepQuality: Int,
    val sleepHours: Double? = null,
    val notes: String = "",
    val updatedAt: LocalDateTime = LocalDateTime.now()
)

@Entity(tableName = "biohacks")
data class BiohackEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val name: String,
    val category: String,
    val description: String,
    val instructions: String,
    val timeRequired: String,
    val difficulty: String,
    val benefits: String,
    val equipmentNeeded: String = "",
    val scientificBacking: String = "",
    val isBookmarked: Boolean = false
)

// ===============================
// 4. DATABASE
// ===============================

// data/database/Converters.kt
package com.yourname.evolv.data.database

import androidx.room.TypeConverter
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

class Converters {
    private val formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME

    @TypeConverter
    fun fromLocalDateTime(dateTime: LocalDateTime?): String? {
        return dateTime?.format(formatter)
    }

    @TypeConverter
    fun toLocalDateTime(dateTimeString: String?): LocalDateTime? {
        return dateTimeString?.let {
            LocalDateTime.parse(it, formatter)
        }
    }
}

// data/database/DAOs.kt
package com.yourname.evolv.data.database

import androidx.room.*
import com.yourname.evolv.data.model.*
import kotlinx.coroutines.flow.Flow
import java.time.LocalDateTime

@Dao
interface HabitDao {
    @Query("SELECT * FROM habits WHERE isActive = 1 ORDER BY createdAt DESC")
    fun getAllActiveHabits(): Flow<List<HabitEntity>>

    @Query("SELECT * FROM habits WHERE id = :habitId")
    suspend fun getHabitById(habitId: Long): HabitEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertHabit(habit: HabitEntity): Long

    @Update
    suspend fun updateHabit(habit: HabitEntity)

    @Delete
    suspend fun deleteHabit(habit: HabitEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertCompletion(completion: HabitCompletionEntity)

    @Query("SELECT * FROM habit_completions WHERE habitId = :habitId AND DATE(completedAt) = DATE(:date)")
    suspend fun getCompletionForDate(habitId: Long, date: LocalDateTime): HabitCompletionEntity?

    @Query("SELECT COUNT(*) FROM habit_completions WHERE habitId = :habitId AND completedAt >= :startDate")
    suspend fun getStreakCount(habitId: Long, startDate: LocalDateTime): Int

    @Query("SELECT * FROM habit_completions ORDER BY completedAt DESC")
    fun getAllCompletions(): Flow<List<HabitCompletionEntity>>
}

@Dao
interface MetricsDao {
    @Query("SELECT * FROM daily_metrics ORDER BY date DESC LIMIT 30")
    fun getRecentMetrics(): Flow<List<DailyMetricEntity>>

    @Query("SELECT * FROM daily_metrics WHERE date = :date")
    suspend fun getMetricsForDate(date: String): DailyMetricEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdateMetrics(metrics: DailyMetricEntity)
}

@Dao
interface BiohackDao {
    @Query("SELECT * FROM biohacks ORDER BY name ASC")
    fun getAllBiohacks(): Flow<List<BiohackEntity>>

    @Query("SELECT * FROM biohacks WHERE category = :category ORDER BY name ASC")
    fun getBiohacksByCategory(category: String): Flow<List<BiohackEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAllBiohacks(biohacks: List<BiohackEntity>)

    @Query("UPDATE biohacks SET isBookmarked = :isBookmarked WHERE id = :biohackId")
    suspend fun updateBookmarkStatus(biohackId: Long, isBookmarked: Boolean)
}

@Dao
interface SubscriptionDao {
    @Query("SELECT * FROM user_subscription WHERE userId = :userId")
    suspend fun getSubscription(userId: String = "default_user"): UserSubscriptionEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdateSubscription(subscription: UserSubscriptionEntity)
}

// data/database/AppDatabase.kt
package com.yourname.evolv.data.database

import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import android.content.Context
import com.yourname.evolv.data.model.*

@Database(
    entities = [
        HabitEntity::class,
        HabitCompletionEntity::class,
        DailyMetricEntity::class,
        BiohackEntity::class,
        UserSubscriptionEntity::class
    ],
    version = 1,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun habitDao(): HabitDao
    abstract fun metricsDao(): MetricsDao
    abstract fun biohackDao(): BiohackDao
    abstract fun subscriptionDao(): SubscriptionDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "evolv_database"
                )
                    .fallbackToDestructiveMigration()
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// ===============================
// 5. SUBSCRIPTION MANAGEMENT
// ===============================

// subscription/SubscriptionManager.kt
package com.yourname.evolv.subscription

import android.app.Activity
import android.content.Context
import com.android.billingclient.api.*
import com.yourname.evolv.data.model.UserTier
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SubscriptionManager @Inject constructor(
    private val context: Context
) : PurchasesUpdatedListener, BillingClientStateListener {

    companion object {
        const val PREMIUM_MONTHLY = "evolv_pro_monthly"
        const val PREMIUM_YEARLY = "evolv_pro_yearly"
        const val ENTERPRISE_MONTHLY = "evolv_teams_monthly"
    }

    private var billingClient: BillingClient = BillingClient.newBuilder(context)
        .setListener(this)
        .enablePendingPurchases()
        .build()

    private val _subscriptionState = MutableStateFlow(SubscriptionState())
    val subscriptionState: StateFlow<SubscriptionState> = _subscriptionState.asStateFlow()

    private val _availableProducts = MutableStateFlow<List<ProductDetails>>(emptyList())
    val availableProducts: StateFlow<List<ProductDetails>> = _availableProducts.asStateFlow()

    init {
        startConnection()
    }

    private fun startConnection() {
        billingClient.startConnection(this)
    }

    override fun onBillingSetupFinished(billingResult: BillingResult) {
        if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
            queryAvailableProducts()
            queryExistingPurchases()
        }
    }

    override fun onBillingServiceDisconnected() {
        startConnection()
    }

    private fun queryAvailableProducts() {
        val productList = listOf(
            QueryProductDetailsParams.Product.newBuilder()
                .setProductId(PREMIUM_MONTHLY)
                .setProductType(BillingClient.ProductType.SUBS)
                .build(),
            QueryProductDetailsParams.Product.newBuilder()
                .setProductId(PREMIUM_YEARLY)
                .setProductType(BillingClient.ProductType.SUBS)
                .build()
        )

        val params = QueryProductDetailsParams.newBuilder()
            .setProductList(productList)
            .build()

        billingClient.queryProductDetailsAsync(params) { billingResult, productDetailsList ->
            if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                _availableProducts.value = productDetailsList
            }
        }
    }

    private fun queryExistingPurchases() {
        val params = QueryPurchasesParams.newBuilder()
            .setProductType(BillingClient.ProductType.SUBS)
            .build()

        billingClient.queryPurchasesAsync(params) { billingResult, purchases ->
            if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                handlePurchases(purchases)
            }
        }
    }

    fun launchBillingFlow(activity: Activity, productDetails: ProductDetails) {
        val productDetailsParamsList = listOf(
            BillingFlowParams.ProductDetailsParams.newBuilder()
                .setProductDetails(productDetails)
                .build()
        )

        val billingFlowParams = BillingFlowParams.newBuilder()
            .setProductDetailsParamsList(productDetailsParamsList)
            .build()

        billingClient.launchBillingFlow(activity, billingFlowParams)
    }

    override fun onPurchasesUpdated(billingResult: BillingResult, purchases: MutableList<Purchase>?) {
        if (billingResult.responseCode == BillingClient.BillingResponseCode.OK && purchases != null) {
            handlePurchases(purchases)
        }
    }

    private fun handlePurchases(purchases: List<Purchase>) {
        purchases.forEach { purchase ->
            if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED) {
                if (!purchase.isAcknowledged) {
                    val acknowledgePurchaseParams = AcknowledgePurchaseParams.newBuilder()
                        .setPurchaseToken(purchase.purchaseToken)
                        .build()
                    
                    billingClient.acknowledgePurchase(acknowledgePurchaseParams) { billingResult ->
                        if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                            updateSubscriptionState(purchase)
                        }
                    }
                } else {
                    updateSubscriptionState(purchase)
                }
            }
        }
    }

    private fun updateSubscriptionState(purchase: Purchase) {
        val tier = when {
            purchase.products.contains(PREMIUM_MONTHLY) || 
            purchase.products.contains(PREMIUM_YEARLY) -> UserTier.PREMIUM
            purchase.products.contains(ENTERPRISE_MONTHLY) -> UserTier.ENTERPRISE
            else -> UserTier.FREE
        }

        _subscriptionState.value = _subscriptionState.value.copy(
            userTier = tier,
            isActive = true,
            purchaseToken = purchase.purchaseToken
        )
    }

    fun getPricingPlans(): List<PricingPlan> {
        return listOf(
            PricingPlan(
                id = PREMIUM_MONTHLY,
                name = "Evolv Pro",
                price = "$9.99",
                billing = "monthly",
                features = getPremiumFeatures(),
                popularBadge = false,
                description = "Perfect for serious biohackers"
            ),
            PricingPlan(
                id = PREMIUM_YEARLY,
                name = "Evolv Pro",
                price = "$79.99",
                billing = "yearly",
                features = getPremiumFeatures(),
                popularBadge = true,
                savings = "Save 33%",
                description = "Best value for committed optimizers"
            )
        )
    }

    private fun getPremiumFeatures(): List<String> = listOf(
        "Unlimited habits",
        "Advanced ML-powered AI insights",
        "Complete biohack library (300+)",
        "Health Connect integration",
        "90-day detailed analytics",
        "Smart notifications",
        "Cloud sync & backup",
        "Advanced progress tracking",
        "Custom habit categories",
        "Priority support"
    )
}

data class SubscriptionState(
    val userTier: UserTier = UserTier.FREE,
    val isActive: Boolean = false,
    val purchaseToken: String? = null,
    val trialDaysRemaining: Int? = null
)

data class PricingPlan(
    val id: String,
    val name: String,
    val price: String,
    val billing: String,
    val features: List<String>,
    val popularBadge: Boolean,
    val savings: String? = null,
    val description: String
)

// subscription/FeatureManager.kt
package com.yourname.evolv.subscription

import com.yourname.evolv.data.model.UserTier
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FeatureManager @Inject constructor() {

    fun canAddMoreHabits(currentHabits: Int, userTier: UserTier): Boolean {
        return when (userTier) {
            UserTier.FREE -> currentHabits < 3
            UserTier.PREMIUM, UserTier.ENTERPRISE -> true
        }
    }

    fun getMaxHabits(userTier: UserTier): Int {
        return when (userTier) {
            UserTier.FREE -> 3
            UserTier.PREMIUM, UserTier.ENTERPRISE -> Int.MAX_VALUE
        }
    }

    fun getAvailableInsights(userTier: UserTier): Int {
        return when (userTier) {
            UserTier.FREE -> 3
            UserTier.PREMIUM, UserTier.ENTERPRISE -> Int.MAX_VALUE
        }
    }

    fun canAccessHealthIntegration(userTier: UserTier): Boolean {
        return userTier != UserTier.FREE
    }

    fun canAccessAdvancedAnalytics(userTier: UserTier): Boolean {
        return userTier != UserTier.FREE
    }

    fun getDataRetentionDays(userTier: UserTier): Int {
        return when (userTier) {
            UserTier.FREE -> 7
            UserTier.PREMIUM -> 90
            UserTier.ENTERPRISE -> 365
        }
    }

    fun canAccessCloudSync(userTier: UserTier): Boolean {
        return userTier != UserTier.FREE
    }

    fun getBiohackLibrarySize(userTier: UserTier): Int {
        return when (userTier) {
            UserTier.FREE -> 50
            UserTier.PREMIUM, UserTier.ENTERPRISE -> 300
        }
    }

    fun canAccessMLInsights(userTier: UserTier): Boolean {
        return userTier != UserTier.FREE
    }
}

// ===============================
// 6. REPOSITORY
// ===============================

// data/repository/EvolvRepository.kt
package com.yourname.evolv.data.repository

import com.yourname.evolv.data.database.AppDatabase
import com.yourname.evolv.data.model.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class EvolvRepository @Inject constructor(
    private val database: AppDatabase
) {
    private val habitDao = database.habitDao()
    private val metricsDao = database.metricsDao()
    private val biohackDao = database.biohackDao()
    private val subscriptionDao = database.subscriptionDao()

    // Habits
    fun getAllActiveHabits(): Flow<List<HabitEntity>> = habitDao.getAllActiveHabits()
    fun getAllCompletions(): Flow<List<HabitCompletionEntity>> = habitDao.getAllCompletions()

    suspend fun getHabitById(habitId: Long): HabitEntity? = habitDao.getHabitById(habitId)
    suspend fun insertHabit(habit: HabitEntity): Long = habitDao.insertHabit(habit)
    suspend fun updateHabit(habit: HabitEntity) = habitDao.updateHabit(habit)
    suspend fun deleteHabit(habit: HabitEntity) = habitDao.deleteHabit(habit)

    suspend fun toggleHabitCompletion(habitId: Long, date: LocalDateTime = LocalDateTime.now()) {
        val existing = habitDao.getCompletionForDate(habitId, date)
        if (existing == null) {
            habitDao.insertCompletion(
                HabitCompletionEntity(
                    habitId = habitId,
                    completedAt = date
                )
            )
        }
    }

    suspend fun getHabitStreak(habitId: Long): Int {
        val thirtyDaysAgo = LocalDateTime.now().minusDays(30)
        return habitDao.getStreakCount(habitId, thirtyDaysAgo)
    }

    // Metrics
    fun getRecentMetrics(): Flow<List<DailyMetricEntity>> = metricsDao.getRecentMetrics()

    suspend fun insertOrUpdateDailyMetrics(metrics: DailyMetricEntity) {
        metricsDao.insertOrUpdateMetrics(metrics)
    }

    suspend fun getTodaysMetrics(): DailyMetricEntity? {
        val today = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"))
        return metricsDao.getMetricsForDate(today)
    }

    // Biohacks
    fun getAllBiohacks(): Flow<List<BiohackEntity>> = biohackDao.getAllBiohacks()

    fun getBiohacksByCategory(category: String): Flow<List<BiohackEntity>> = 
        biohackDao.getBiohacksByCategory(category)

    suspend fun toggleBiohackBookmark(biohackId: Long, isBookmarked: Boolean) {
        biohackDao.updateBookmarkStatus(biohackId, isBookmarked)
    }

    suspend fun insertBiohacks(biohacks: List<BiohackEntity>) {
        biohackDao.insertAllBiohacks(biohacks)
    }

    // Subscription
    suspend fun getSubscription(): UserSubscriptionEntity? = 
        subscriptionDao.getSubscription()

    suspend fun updateSubscription(subscription: UserSubscriptionEntity) {
        subscriptionDao.insertOrUpdateSubscription(subscription)
    }

    // Combined data for dashboard
    fun getDashboardData(): Flow<DashboardData> {
        return combine(
            getAllActiveHabits(),
            getRecentMetrics()
        ) { habits, metrics ->
            DashboardData(
                habits = habits,
                recentMetrics = metrics.take(7),
                aiInsights = generateBasicInsights(habits, metrics)
            )
        }
    }

    private fun generateBasicInsights(habits: List<HabitEntity>, metrics: List<DailyMetricEntity>): List<String> {
        val insights = mutableListOf<String>()
        
        if (metrics.isNotEmpty()) {
            val avgEnergy = metrics.map { it.energy }.average()
            val avgFocus = metrics.map { it.focus }.average()
            
            if (avgEnergy > 7.5) {
                insights.add("Your energy levels are consistently high - great job maintaining your routine!")
            }
            if (avgFocus > 7.0) {
                insights.add("Your focus scores show improvement - meditation habits are paying off!")
            }
        }
        
        if (habits.any { it.category == "Focus" }) {
            insights.add("Consider adding a 'Digital Detox' habit to further boost your focus metrics")
        }
        
        return insights.ifEmpty { 
            listOf("Start tracking your daily metrics to get personalized AI insights!")
        }
    }
}

data class DashboardData(
    val habits: List<HabitEntity>,
    val recentMetrics: List<DailyMetricEntity>,
    val aiInsights: List<String>
)

// ===============================
// 7. VIEWMODELS
// ===============================

// ui/viewmodel/DashboardViewModel.kt
package com.yourname.evolv.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.yourname.evolv.data.repository.EvolvRepository
import com.yourname.evolv.data.repository.DashboardData
import com.yourname.evolv.data.model.DailyMetricEntity
import com.yourname.evolv.data.model.HabitEntity
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import javax.inject.Inject

@HiltViewModel
class DashboardViewModel @Inject constructor(
    private val repository: EvolvRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(DashboardUiState())
    val uiState: StateFlow<DashboardUiState> = _uiState.asStateFlow()

    init {
        loadDashboardData()
    }

    private fun loadDashboardData() {
        viewModelScope.launch {
            repository.getDashboardData().collect { dashboardData ->
                _uiState.value = _uiState.value.copy(
                    habits = dashboardData.habits,
                    metrics = dashboardData.recentMetrics,
                    aiInsights = dashboardData.aiInsights,
                    isLoading = false
                )
            }
        }
    }

    fun toggleHabitCompletion(habitId: Long) {
        viewModelScope.launch {
            repository.toggleHabitCompletion(habitId)
        }
    }

    fun updateDailyRating(metric: String, value: Int) {
        viewModelScope.launch {
            val todaysMetrics = repository.getTodaysMetrics()
            val updatedMetrics = when (metric) {
                "energy" -> todaysMetrics?.copy(energy = value) ?: createTodaysMetrics().copy(energy = value)
                "focus" -> todaysMetrics?.copy(focus = value) ?: createTodaysMetrics().copy(focus = value)
                "mood" -> todaysMetrics?.copy(mood = value) ?: createTodaysMetrics().copy(mood = value)
                "productivity" -> todaysMetrics?.copy(productivity = value) ?: createTodaysMetrics().copy(productivity = value)
                else -> return@launch
            }
            repository.insertOrUpdateDailyMetrics(updatedMetrics)
        }
    }

    private fun createTodaysMetrics() = DailyMetricEntity(
        date = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd")),
        energy = 5,
        focus = 5,
        mood = 5,
        productivity = 5,
        sleepQuality = 5
    )
}

data class DashboardUiState(
    val habits: List<HabitEntity> = emptyList(),
    val metrics: List<DailyMetricEntity> = emptyList(),
    val aiInsights: List<String> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null
)

// ui/viewmodel/HabitsViewModel.kt
package com.yourname.evolv.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.yourname.evolv.data.model.HabitEntity
import com.yourname.evolv.data.repository.EvolvRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class HabitsViewModel @Inject constructor(
    private val repository: EvolvRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(HabitsUiState())
    val uiState: StateFlow<HabitsUiState> = _uiState.asStateFlow()

    init {
        loadHabits()
    }

    private fun loadHabits() {
        viewModelScope.launch {
            repository.getAllActiveHabits().collect { habits ->
                _uiState.value = _uiState.value.copy(
                    habits = habits,
                    isLoading = false
                )
            }
        }
    }

    fun addHabit(name: String, category: String, timeRequired: String, difficulty: String = "Easy") {
        viewModelScope.launch {
            val habit = HabitEntity(
                name = name,
                category = category,
                timeRequired = timeRequired,
                difficulty = difficulty
            )
            repository.insertHabit(habit)
        }
    }

    fun toggleHabitCompletion(habitId: Long) {
        viewModelScope.launch {
            repository.toggleHabitCompletion(habitId)
        }
    }

    fun deleteHabit(habit: HabitEntity) {
        viewModelScope.launch {
            repository.deleteHabit(habit)
        }
    }
}

data class HabitsUiState(
    val habits: List<HabitEntity> = emptyList(),
    val isLoading: Boolean = true,
    val error: String? = null
)

// ===============================
// 8. UI THEME
// ===============================

// ui/theme/Color.kt
package com.yourname.evolv.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

// Evolv Brand Colors
val EvolvPurple = Color(0xFF8B5CF6)
val EvolvBlue = Color(0xFF3B82F6)
val EvolvTeal = Color(0xFF14B8A6)
val EvolvGreen = Color(0xFF10B981)
val EvolvOrange = Color(0xFFF59E0B)
val EvolvRed = Color(0xFFEF4444)
val EvolvPink = Color(0xFFEC4899)

// Neutral Colors
val Gray50 = Color(0xFFF9FAFB)
val Gray100 = Color(0xFFF3F4F6)
val Gray200 = Color(0xFFE5E7EB)
val Gray300 = Color(0xFFD1D5DB)
val Gray400 = Color(0xFF9CA3AF)
val Gray500 = Color(0xFF6B7280)
val Gray600 = Color(0xFF4B5563)
val Gray700 = Color(0xFF374151)
val Gray800 = Color(0xFF1F2937)
val Gray900 = Color(0xFF111827)

// ui/theme/Type.kt
package com.yourname.evolv.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
)

// ui/theme/Theme.kt
package com.yourname.evolv.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = EvolvPurple,
    secondary = EvolvBlue,
    tertiary = EvolvTeal,
    background = Gray900,
    surface = Gray800,
    onPrimary = androidx.compose.ui.graphics.Color.White,
    onSecondary = androidx.compose.ui.graphics.Color.White,
    onTertiary = androidx.compose.ui.graphics.Color.White,
    onBackground = Gray100,
    onSurface = Gray100,
)

private val LightColorScheme = lightColorScheme(
    primary = EvolvPurple,
    secondary = EvolvBlue,
    tertiary = EvolvTeal,
    background = Gray50,
    surface = androidx.compose.ui.graphics.Color.White,
    onPrimary = androidx.compose.ui.graphics.Color.White,
    onSecondary = androidx.compose.ui.graphics.Color.White,
    onTertiary = androidx.compose.ui.graphics.Color.White,
    onBackground = Gray900,
    onSurface = Gray900,
)

@Composable
fun EvolvTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

// ===============================
// 9. UI COMPONENTS
// ===============================

// ui/components/Charts.kt
package com.yourname.evolv.ui.components

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.yourname.evolv.data.model.DailyMetricEntity
import kotlin.math.*

@Composable
fun ProgressLineChart(
    data: List<DailyMetricEntity>,
    metric: String,
    color: Color,
    modifier: Modifier = Modifier
) {
    val values = when (metric) {
        "energy" -> data.map { it.energy.toFloat() }
        "focus" -> data.map { it.focus.toFloat() }
        "mood" -> data.map { it.mood.toFloat() }
        "productivity" -> data.map { it.productivity.toFloat() }
        else -> data.map { it.energy.toFloat() }
    }

    Card(
        modifier = modifier,
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.cardColors(containerColor = Color.White)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = metric.replaceFirstChar { it.uppercase() },
                fontWeight = FontWeight.Bold,
                fontSize = 16.sp
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Canvas(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(120.dp)
            ) {
                drawLineChart(values, color)
            }
        }
    }
}

private fun DrawScope.drawLineChart(values: List<Float>, color: Color) {
    if (values.size < 2) return
    
    val maxValue = 10f
    val minValue = 0f
    val range = maxValue - minValue
    
    val stepX = size.width / (values.size - 1)
    val stepY = size.height / range
    
    val points = values.mapIndexed { index, value ->
        Offset(
            x = index * stepX,
            y = size.height - ((value - minValue) * stepY)
        )
    }
    
    // Draw gradient fill
    val gradientPath = Path().apply {
        moveTo(points.first().x, size.height)
        points.forEach { point ->
            lineTo(point.x, point.y)
        }
        lineTo(points.last().x, size.height)
        close()
    }
    
    drawPath(
        path = gradientPath,
        brush = Brush.verticalGradient(
            colors = listOf(
                color.copy(alpha = 0.3f),
                Color.Transparent
            )
        )
    )
    
    // Draw line
    for (i in 0 until points.size - 1) {
        drawLine(
            color = color,
            start = points[i],
            end = points[i + 1],
            strokeWidth = 3.dp.toPx(),
            cap = StrokeCap.Round
        )
    }
    
    // Draw points
    points.forEach { point ->
        drawCircle(
            color = color,
            radius = 4.dp.toPx(),
            center = point
        )
        drawCircle(
            color = Color.White,
            radius = 2.dp.toPx(),
            center = point
        )
    }
}

@Composable
fun CircularProgressChart(
    progress: Float,
    label: String,
    color: Color,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        shape = RoundedCornerShape(16.dp),
        colors = CardDefaults.cardColors(containerColor = Color.White)
    ) {
        Column(
            modifier = Modifier.padding(20.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Box(
                contentAlignment = Alignment.Center,
                modifier = Modifier.size(80.dp)
            ) {
                Canvas(modifier = Modifier.fillMaxSize()) {
                    val strokeWidth = 8.dp.toPx()
                    val radius = (size.minDimension - strokeWidth) / 2
                    val center = Offset(size.width / 2, size.height / 2)
                    
                    // Background circle
                    drawCircle(
                        color = Color.Gray.copy(alpha = 0.2f),
                        radius = radius,
                        center = center,
                        style = Stroke(strokeWidth)
                    )
                    
                    // Progress arc
                    drawArc(
                        color = color,
                        startAngle = -90f,
                        sweepAngle = 360f * progress,
                        useCenter = false,
                        style = Stroke(strokeWidth, cap = StrokeCap.Round),
                        topLeft = Offset(
                            center.x - radius,
                            center.y - radius
                        ),
                        size = androidx.compose.ui.geometry.Size(radius * 2, radius * 2)
                    )
                }
                
                Text(
                    text = "${(progress * 100).toInt()}%",
                    fontWeight = FontWeight.Bold,
                    fontSize = 16.sp,
                    color = color
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = label,
                fontSize = 12.sp,
                color = Color.Gray
            )
        }
    }
}

// ui/components/PaywallDialog.kt
package com.yourname.evolv.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun PaywallDialog(
    feature: String,
    onUpgrade: () -> Unit,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Box(
                    modifier = Modifier
                        .size(60.dp)
                        .background(
                            Brush.radialGradient(
                                colors = listOf(Color(0xFF8B5CF6), Color(0xFF3B82F6))
                            ),
                            RoundedCornerShape(16.dp)
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        Icons.Default.Lock,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(30.dp)
                    )
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Text(
                    "Unlock $feature",
                    fontSize = 20.sp,
                    fontWeight = FontWeight.Bold,
                    textAlign = TextAlign.Center
                )
            }
        },
        text = {
            Column {
                Text(
                    "You've reached the limit for free users. Upgrade to Pro to unlock:",
                    fontSize = 14.sp,
                    color = Color.Gray,
                    textAlign = TextAlign.Center
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                val benefits = when (feature) {
                    "habits" -> listOf(
                        "Unlimited habits",
                        "Advanced AI insights",
                        "Health app integration"
                    )
                    "insights" -> listOf(
                        "Unlimited AI insights",
                        "ML-powered recommendations",
                        "Predictive analytics"
                    )
                    "analytics" -> listOf(
                        "90-day data history",
                        "Advanced charts",
                        "Export capabilities"
                    )
                    else -> listOf(
                        "All premium features",
                        "Unlimited usage",
                        "Priority support"
                    )
                }
                
                benefits.forEach { benefit ->
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Icon(
                            Icons.Default.Check,
                            contentDescription = null,
                            tint = Color(0xFF10B981),
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            benefit,
                            fontSize = 14.sp
                        )
                    }
                    Spacer(modifier = Modifier.height(4.dp))
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = Color(0xFF10B981).copy(alpha = 0.1f)
                    )
                ) {
                    Text(
                        "✨ 14-day free trial • Cancel anytime",
                        modifier = Modifier.padding(12.dp),
                        fontSize = 12.sp,
                        color = Color(0xFF10B981),
                        textAlign = TextAlign.Center
                    )
                }
            }
        },
        confirmButton = {
            Button(
                onClick = onUpgrade,
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFF8B5CF6)
                )
            ) {
                Text("Upgrade to Pro")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Maybe Later")
            }
        }
    )
}

// ===============================
// 10. MAIN APP SCREENS
// ===============================

// MainActivity.kt
package com.yourname.evolv

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.viewModels
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.yourname.evolv.ui.theme.EvolvTheme
import com.yourname.evolv.ui.viewmodel.*
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    
    private val dashboardViewModel: DashboardViewModel by viewModels()
    private val habitsViewModel: HabitsViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            EvolvTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    EvolvApp(
                        dashboardViewModel = dashboardViewModel,
                        habitsViewModel = habitsViewModel
                    )
                }
            }
        }
    }
}

// EvolvApp.kt
package com.yourname.evolv

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.yourname.evolv.ui.viewmodel.*
import com.yourname.evolv.ui.components.*
import com.yourname.evolv.data.model.HabitEntity

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EvolvApp(
    dashboardViewModel: DashboardViewModel,
    habitsViewModel: HabitsViewModel
) {
    var selectedTab by remember { mutableIntStateOf(0) }
    var showPaywall by remember { mutableStateOf(false) }
    var paywallFeature by remember { mutableStateOf("") }
    
    val tabs = listOf(
        TabItem("Dashboard", Icons.Default.Home),
        TabItem("Habits", Icons.Default.CheckCircle),
        TabItem("Discover", Icons.Default.Explore),
        TabItem("Progress", Icons.Default.TrendingUp)
    )

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Box(
                            modifier = Modifier
                                .size(40.dp)
                                .background(
                                    Brush.horizontalGradient(
                                        colors = listOf(
                                            Color(0xFF8B5CF6),
                                            Color(0xFF3B82F6)
                                        )
                                    ),
                                    RoundedCornerShape(12.dp)
                                ),
                            contentAlignment = Alignment.Center
                        ) {
                            Icon(
                                Icons.Default.Psychology,
                                contentDescription = null,
                                tint = Color.White,
                                modifier = Modifier.size(20.dp)
                            )
                        }
                        Column {
                            Text(
                                "Evolv",
                                fontSize = 20.sp,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                "AI-Powered Evolution",
                                fontSize = 12.sp,
                                color = Color.Gray
                            )
                        }
                    }
                },
                actions = {
                    IconButton(onClick = { }) {
                        Icon(Icons.Default.Settings, contentDescription = "Settings")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = Color.White
                )
            )
        },
        bottomBar = {
            NavigationBar(
                containerColor = Color.White
            ) {
                tabs.forEachIndexed { index, tab ->
                    NavigationBarItem(
                        icon = {
                            Icon(
                                tab.icon,
                                contentDescription = tab.title,
                                tint = if (selectedTab == index) Color(0xFF8B5CF6) else Color.Gray
                            )
                        },
                        label = {
                            Text(
                                tab.title,
                                fontSize = 10.sp,
                                color = if (selectedTab == index) Color(0xFF8B5CF6) else Color.Gray
                            )
                        },
                        selected = selectedTab == index,
                        onClick = { selectedTab = index }
                    )
                }
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(Color(0xFFF9FAFB))
        ) {
            when (selectedTab) {
                0 -> {
                    val uiState by dashboardViewModel.uiState.collectAsStateWithLifecycle()
                    DashboardScreen(
                        uiState = uiState,
                        onToggleHabit = { habitId -> dashboardViewModel.toggleHabitCompletion(habitId) },
                        onUpdateRating = { metric, value -> dashboardViewModel.updateDailyRating(metric, value) }
                    )
                }
                1 -> {
                    val uiState by habitsViewModel.uiState.collectAsStateWithLifecycle()
                    HabitsScreen(
                        uiState = uiState,
                        onToggleHabit = { habitId -> habitsViewModel.toggleHabitCompletion(habitId) },
                        onAddHabit = { name, category, time -> 
                            // Check if user can add more habits (free tier limitation)
                            if (uiState.habits.size >= 3) {
                                paywallFeature = "habits"
                                showPaywall = true
                            } else {
                                habitsViewModel.addHabit(name, category, time)
                            }
                        }
                    )
                }
                2 -> DiscoverScreen()
                3 -> ProgressScreen()
            }
        }
    }
    
    // Paywall Dialog
    if (showPaywall) {
        PaywallDialog(
            feature = paywallFeature,
            onUpgrade = { 
                // Navigate to subscription screen
                showPaywall = false
            },
            onDismiss = { showPaywall = false }
        )
    }
}

data class TabItem(val title: String, val icon: ImageVector)

// Dashboard Screen
@Composable
fun DashboardScreen(
    uiState: DashboardUiState,
    onToggleHabit: (Long) -> Unit,
    onUpdateRating: (String, Int) -> Unit
) {
    LazyColumn(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Welcome Header
        item {
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(24.dp),
                colors = CardDefaults.cardColors(containerColor = Color.Transparent)
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .background(
                            Brush.horizontalGradient(
                                colors = listOf(
                                    Color(0xFF8B5CF6),
                                    Color(0xFF3B82F6),
                                    Color(0xFF14B8A6)
                                )
                            )
                        )
                        .padding(24.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                "Good Morning! 🌅",
                                fontSize = 24.sp,
                                fontWeight = FontWeight.Bold,
                                color = Color.White
                            )